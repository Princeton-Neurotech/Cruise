{"ast":null,"code":"import _classCallCheck from \"/Users/leilahudson/Documents/GitHub/Startup/Cruise/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/leilahudson/Documents/GitHub/Startup/Cruise/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"/Users/leilahudson/Documents/GitHub/Startup/Cruise/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nvar _ConsoleMethod;\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n/**\r\n * A container for all of the Logger instances\r\n */\nvar instances = [];\n/**\r\n * The JS SDK supports 5 log levels and also allows a user the ability to\r\n * silence the logs altogether.\r\n *\r\n * The order is a follows:\r\n * DEBUG < VERBOSE < INFO < WARN < ERROR\r\n *\r\n * All of the log types above the current log level will be captured (i.e. if\r\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\r\n * `VERBOSE` logs will not)\r\n */\nvar LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n  LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n  LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n  LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n  LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n  LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\nvar levelStringToEnum = {\n  'debug': LogLevel.DEBUG,\n  'verbose': LogLevel.VERBOSE,\n  'info': LogLevel.INFO,\n  'warn': LogLevel.WARN,\n  'error': LogLevel.ERROR,\n  'silent': LogLevel.SILENT\n};\n/**\r\n * The default log level\r\n */\nvar defaultLogLevel = LogLevel.INFO;\n/**\r\n * By default, `console.debug` is not displayed in the developer console (in\r\n * chrome). To avoid forcing users to have to opt-in to these logs twice\r\n * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\r\n * logs to the `console.log` function.\r\n */\nvar ConsoleMethod = (_ConsoleMethod = {}, _defineProperty(_ConsoleMethod, LogLevel.DEBUG, 'log'), _defineProperty(_ConsoleMethod, LogLevel.VERBOSE, 'log'), _defineProperty(_ConsoleMethod, LogLevel.INFO, 'info'), _defineProperty(_ConsoleMethod, LogLevel.WARN, 'warn'), _defineProperty(_ConsoleMethod, LogLevel.ERROR, 'error'), _ConsoleMethod);\n/**\r\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\r\n * messages on to their corresponding console counterparts (if the log method\r\n * is supported by the current log level)\r\n */\nvar defaultLogHandler = function defaultLogHandler(instance, logType) {\n  if (logType < instance.logLevel) {\n    return;\n  }\n  var now = new Date().toISOString();\n  var method = ConsoleMethod[logType];\n  if (method) {\n    var _console;\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    (_console = console)[method].apply(_console, [\"[\".concat(now, \"]  \").concat(instance.name, \":\")].concat(args));\n  } else {\n    throw new Error(\"Attempted to log a message with an invalid logType (value: \".concat(logType, \")\"));\n  }\n};\nvar Logger = /*#__PURE__*/function () {\n  /**\r\n   * Gives you an instance of a Logger to capture messages according to\r\n   * Firebase's logging scheme.\r\n   *\r\n   * @param name The name that the logs will be associated with\r\n   */\n  function Logger(name) {\n    _classCallCheck(this, Logger);\n    this.name = name;\n    /**\r\n     * The log level of the given Logger instance.\r\n     */\n    this._logLevel = defaultLogLevel;\n    /**\r\n     * The main (internal) log handler for the Logger instance.\r\n     * Can be set to a new function in internal package code but not by user.\r\n     */\n    this._logHandler = defaultLogHandler;\n    /**\r\n     * The optional, additional, user-defined log handler for the Logger instance.\r\n     */\n    this._userLogHandler = null;\n    /**\r\n     * Capture the current instance for later use\r\n     */\n    instances.push(this);\n  }\n  _createClass(Logger, [{\n    key: \"logLevel\",\n    get: function get() {\n      return this._logLevel;\n    },\n    set: function set(val) {\n      if (!(val in LogLevel)) {\n        throw new TypeError(\"Invalid value \\\"\".concat(val, \"\\\" assigned to `logLevel`\"));\n      }\n      this._logLevel = val;\n    }\n    // Workaround for setter/getter having to be the same type.\n  }, {\n    key: \"setLogLevel\",\n    value: function setLogLevel(val) {\n      this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;\n    }\n  }, {\n    key: \"logHandler\",\n    get: function get() {\n      return this._logHandler;\n    },\n    set: function set(val) {\n      if (typeof val !== 'function') {\n        throw new TypeError('Value assigned to `logHandler` must be a function');\n      }\n      this._logHandler = val;\n    }\n  }, {\n    key: \"userLogHandler\",\n    get: function get() {\n      return this._userLogHandler;\n    },\n    set: function set(val) {\n      this._userLogHandler = val;\n    }\n    /**\r\n     * The functions below are all based on the `console` interface\r\n     */\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.DEBUG].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.DEBUG].concat(args));\n    }\n  }, {\n    key: \"log\",\n    value: function log() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.VERBOSE].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.VERBOSE].concat(args));\n    }\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.INFO].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.INFO].concat(args));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        args[_key5] = arguments[_key5];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.WARN].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.WARN].concat(args));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n        args[_key6] = arguments[_key6];\n      }\n      this._userLogHandler && this._userLogHandler.apply(this, [this, LogLevel.ERROR].concat(args));\n      this._logHandler.apply(this, [this, LogLevel.ERROR].concat(args));\n    }\n  }]);\n  return Logger;\n}();\nfunction setLogLevel(level) {\n  instances.forEach(function (inst) {\n    inst.setLogLevel(level);\n  });\n}\nfunction setUserLogHandler(logCallback, options) {\n  var _iterator = _createForOfIteratorHelper(instances),\n    _step;\n  try {\n    var _loop = function _loop() {\n      var instance = _step.value;\n      var customLogLevel = null;\n      if (options && options.level) {\n        customLogLevel = levelStringToEnum[options.level];\n      }\n      if (logCallback === null) {\n        instance.userLogHandler = null;\n      } else {\n        instance.userLogHandler = function (instance, level) {\n          for (var _len7 = arguments.length, args = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {\n            args[_key7 - 2] = arguments[_key7];\n          }\n          var message = args.map(function (arg) {\n            if (arg == null) {\n              return null;\n            } else if (typeof arg === 'string') {\n              return arg;\n            } else if (typeof arg === 'number' || typeof arg === 'boolean') {\n              return arg.toString();\n            } else if (arg instanceof Error) {\n              return arg.message;\n            } else {\n              try {\n                return JSON.stringify(arg);\n              } catch (ignored) {\n                return null;\n              }\n            }\n          }).filter(function (arg) {\n            return arg;\n          }).join(' ');\n          if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {\n            logCallback({\n              level: LogLevel[level].toLowerCase(),\n              message: message,\n              args: args,\n              type: instance.name\n            });\n          }\n        };\n      }\n    };\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nexport { LogLevel, Logger, setLogLevel, setUserLogHandler };","map":null,"metadata":{},"sourceType":"module"}